<프로젝트>

서버 리팩토링

코드를 깔끔하게 바꿈. 
버전 관리 방법
- git, github 사용
DB를 nodejs와 접목(mtSQL, mongoDB)
twitter 기능을 DB와 연결하여 웹 소켓과 함께 마무리


포스트맨
Variavles
-반복될 url을 저장할 변수
http://localhost:8080


-Create New Collection
url에 {{ 입력하면 저장해놓은 변수가 뜸
- Query Params
key에 username이라고 쓰면 url에 ?username이라고 붙는다.
value에 '김사과'를 넣으면 url에 =김사과가 붙는다.

React는
nodejs 기반으로 돌아가는 앱처럼 구현하기 위한 FE Tool
✔ npm audit fix --force
- Nodejs의 최신버전과 React가 호환되지않는 부분이 있어서, 위 명령을 실행한 후에 정상적으로 작동함(종속성 코드를 수정)
 - npm run start로 실행해야 함

강사님이 주신 client 파일 깔고 해당 폴더에서 아래 명령어 실행
 npm install -> npm audit fix --force -> npm run start

 index.js 
 렌더링하는 첫화면
 ReactDOM.render()

 App.jsx
 - jsx: react에서 사용하는 언어 이름. javascript 태그를 이용해서 html과 비슷한 방법으로 화면을 구성한다.
 - 확장명을 js라고 해도되지만, js를 많이 쓰면, 파일들이 실제 화면을 구성하는것인지, 계산해주는 것인지 헷갈림. 눈에 보이는 화면은 jsx를 많이 쓰고, service단(계산되는 부분)은 js라고 써버릇함
 - 컴포넌트: 화면의 재활용을 위해, 조각조각내고 파라미터를 넣어서 재사용이 가능하게 함(버튼 하나도 컴포넌트로 만듬)


.env의 역할
내용을 전역으로 데이터를 가져감

8080은 노드 서버에 붙는 것
3000은 리액트가 돌아감
3000 -> 8080으로 붙으려고 하는거라서 .env에서 8080을 쓴것




<Day7>
auth (=인증)
1. 세션, 쿠키를 이용한 인증 (전통적인 웹 개발 방식)
    - client가 server로 페이지를 요청해서 페이지를 돌려받을 때 사용하는 인증 방법 (API를 요청하는 것이 아니라)
    - 세션, 쿠키란? 서버에 클라이언트가 접속하면, 웹 서버는 client가 내 웹 서버에 들어왔다는 것을 알고, req객체가 만들어짐. 서버 메모리에 기억이되고, 세션 ID라는 유일한 값(긴 번호, 중복X)를 만든다.  client쪽으로 브라우저 저장소에 세션 ID을 추가 내용과 함께 다운로드 받게함. 그 다운로드 받는것을 쿠키라고 함
    다운로드 후에 server와 client는 끊어진다.
    - 서버 메모리에 이사람이 들어왔구나~ 하고 저장되는 사용자 정보는 세션. 정보 파일이 클라이언트쪽으로 심어지는게 그것을 쿠키라고함
    - 세션 id는 시간설정이 가능함.(기본값이 25~30분). 첫페이지를 요청하고 세션 id를 부여받은 후, 쿠키를 다운받고나서 설정한 시간이 지나고 다시 접속하면 메모리에 있는 세션 id가 지워진다. 다시 세션 id를 발급하고 다시 주게된다. 사용자가 계속 오면 메모리가 부족해지니까.
 ✔ 로그인
    - 입력한 ID, PW를 서버에 보내면 DB에 그 정보가 있는지 물어보고, 있다면 세션 ID 밑으로 변수를 만들어서(userID) 입력한 로그인관련 정보를 저장함
    세션 ID만 있다면 익명 사용자고, 그 밑으로 변수가 있으면 로그인된 사용자인것을 알 수 있다.
✔ 장점
    - 이미 만들어져있는 세션이라는 기능과 쿠키라는 준비된 기능을 이용하다보니, 개발이 편하고 보안이 우수하다.
✔ 단점
    - 메모리에서 계속 세션 ID를 만들어주고 변수를 만들어줘야함. 로그인 정보를 파일이나 DB에 저장하면 해결할 수 있음
    - 접속자가 많이 몰릴 경우 서버 증설이 필요함. 같은 홈페이지를 각 서버가 가져야하며, DB는 동일, DB도 부하가 감. DB도 여러개를 만들게 되면, 동기화를 시켜야 함. 메모리도 동기화를 시켜줘야 함(페이지 이동하다 다른 서버에 접속하게 되는경우 세션 ID를 또 만들어줘야 하므로)

2. JWT(Json Web Token)를 이용한 인증
    - Json형태를 세 부분으로 나눌 수 있음 
       header: 어떤 알고리즘으로 암호화 했는지
       payload: 보내고싶은 내용 (ID, PW, 이름 등등)
       signature: 데이터 인코딩 방법
    - 앱으로 개발하여 브라우저가 없는 경우 통신에 사용
    - 셋톱박스(채널 수신기)안에 있는 안드로이드 기기에서 통신할 때 사용

body는 express-validator에서 제공하는 함수로, 요청 본문(body)에서 값을 가져올 수 있도록 도와주는 역할을 합니다.

Bearer
json 스키마 값
-Value 에 입력: Bearer 토큰값


<0508 트윗 사용하기>
1. 토큰을 사용해야하고, 토큰을 사용할 수 있도록 index.js에 가져와야 함(tokenStorage 추가)
    const tweetService = new TweetService(httpClient, tokenStorage);

2. Client - service - tweet.js로 가서 constructor 매개변수값으로 tokenStorage추가 및 this.tokenStorage = tokenStorage; 프로퍼티로 등록

3. 토큰을 꺼낼 수 있게하는 함수만들기 -> fetch를 이용해서 API로 접근할 때 토큰을 이용할 수 있음(네트워크로 데이터를 보내고,받는 함수에 Headers에 넣어야 함)
    ✔ 왜 headers에 토큰을 넣어야 하는가?
    HTTP 요청을 보낼 때, 클라이언트와 서버 간의 인증 정보나 추가적인 데이터를 전달하기 위해 헤더를 사용합니다.
    HTTP 헤더는 요청이나 응답의 메타데이터를 전달하는 데 사용되며, 클라이언트와 서버 간의 통신을 지원하는 핵심 요소 중 하나입니다.
    인증을 위해 사용되는 토큰 정보는 주로 HTTP 요청의 Authorization 헤더에 포함됩니다. 
    이를 통해 서버는 클라이언트의 인증 정보를 확인하고, 클라이언트는 서버에서 보호되는 자원에 접근할 수 있습니다. 
    따라서 fetch 메서드로 서버에 요청을 보낼 때는, 인증을 위해 사용되는 토큰 정보를 HTTP 요청의 Authorization 헤더에 넣어서 보내야 합니다.

<0508 트윗 수정/삭제_로그인 후 계정으로 작성한 트윗에 대해서만 수정/삭제 가능하도록>
1. controller - tweets.js에서 updateTweet, deleteTweet 수정


<0509>
- 서버 포트넘버/시크릿키는 환경변수에 넣어놓고, 서버를 다시 시작할때마다 실행할 수 있도록 한다.(env파일에 대한 내용을 서버에 적용)
    - env파일에 접근하기 위해서는 process.을 이용할 수 있지만, 상수값이 등록되지 않았거나 오타가 있는경우 프로그램을 짜서 
    env파일을 사용하려고 하는게 dotenv다.
    - npm i dorenv로 설치.
    - config.js 파일을 만들어서 env파일을 import하여 코드를 짜야함.(env파일에 직접 코드를 짤 수 없다.)
    - env 파일은 공유해서는 안됨

- config.js를 controller, middleware내 auth.js에 import하여 해당되는 값들을 config.jwt.키값 으로 바꿔준다


✔ 소켓: 서버와 클라이언트가 실시간 통신을하기 위한 통신 방법
    계속 연결상태로 유지되어야 하는 채팅이나, 방송 등

    - HTTP 통신의 특징
    1. 클라이언트에서 서버쪽으로 요청을 해야 응답을 받을 수 있음
    2. 클라이언트에서 데이터를 받은 후 연결을 끊음
- 서버
    - 서버에 npm i socket.io로 설치
      (서버는 사용자 대기하다가 신호를 받으면 실시간으로 소켓이 연결되는데, 동일한 클라이언트 소켓을 연결함)
      
    - 서버는 두가지 소켓이 있다. 
        1. 기다리는 소켓
        2. 클라이언트-서버와 연결을 위한 일반 소켓을 가지고 있음

- 클라이언트
    - 클라이언트에는 npm i socket.io-client로 설치
    - 클라이언트 소켓은 연결을 위한 소켓 하나만 있다.

- 소켓은 이벤트 기반으로 움직인다. 사용자가 이벤트를 발생시키면 그 이벤트에 의해 처리가 됨
    ✔ .on()은 어떤 이벤트가 발생하면 비동기처리 함수를 작동시킨다. 'connection'은 사용자가 연결될때 함수를 처리.
    
    ✔  .emit()은 소켓에 접속된 사용자에게 이벤트를 발생시켜줌


server - index.js
    import { Server } from 'socket.io'

    const socketIO = new Server(server, {
    cors: {
        origin: '*' 
    }
    });

    socketIO.on('connection', ()=>{
    console.log('클라이언트 연결 성공!');
    socketIO.emit('dwitter', 'Hello 🍊');
}) 

client - index.js
    import socket from 'socket.io-client';

    const socketIO = socket(baseURL)
    socketIO.on('connect_error', (error) => {
    console.log('소켓 에러!', error)
    })
    socketIO.on('dwitter', (msg) => console.log(msg));

서버에 붙어있는 사용자에게 .emit를 보내면 새로고침하지 않아도 생성된 트윗이 올라온다(controller - tweets.js - function createTweet안에 .emit메서드를 포함). getAll을 다시 해주면 됨.
    - socketIO.emit('dwitter', 'Hello 🍊');를 트윗 쓰는쪽으로 보내기. (소켓 객체가 없으니까, class를 만들거나 parameter로 보내야함)


DataBase: 데이터 저장소
RDBMS(관계형 데이터 베이스): 나누거나 합칠 수 있는 DB
    - sql이라는 언어를 사용하는 것이 다른 DBMS와의 차이점
    - table을 사용
    - key가 중요. 
        -> PK(not null, unique, 하나만 지정가능(mySQL한정), 외부 테이블에서 참조 가능, indexing 기능(where절에 넣으면 검색 속도가 빨라짐)), 
        - FK
    - NoSQL: sql을 사용하지 않는 다른 dbms를 말할때 사용

✔ RDBMS 종류
- Oracle
- mySQL
- MS-SQL
- PostgreSQL
- SQLite

✔ NoSQL 특징
- Key-Value
- Document(컬렉션. 그룹 안에서 key-value방식으로 저장)
- Wide-colum(2차원으로 key-value를 저장하는 방식)
- Graph(트리 형태로 데이터가 저장되며, 순환형(데이터가 다시 돌아옴) 알고리즘)

✔ ORM / ODM
- ORM(Object Relational Maping)
    sql언어를 몰라도 객체로만 DB와연동하게 해줌
    언어에 있는 기능
    자바스크립트에서 사용하는 ORM: TYPEORM, Sequelize, Prisma
    
- ODM(Object Document Mapper)
    라이브러리를 통해서 움직임
    몽고 DB에서 사용하는 ODM: mongoose


스토리보드(관리자 포함) 보고 sql문 작성(2일동안)
[회원가입 -> 로그인 -> 메인 -> 서브 -> ...]
- 모든 페이지를 보고 각 페이지에 쓰이는 SQL문장 써보자.
    - 회원가입 시 insert 구문이 동작
    - 로그인 버튼 누르면 select 
    - main에서 게시물을 보이게 하거나 지도에서 보이게하기
- 스키마대로 DB와 테이블을 만들어보기.
- 이거 다 만들고나서 API만들 것임

<0510>
- db와 연동하기 위해 라이브러리 설치
    npm i mysql2
- mySQL Woirkbench에서 테이블 두개 만들고 PK, FK 지정

- Server 폴더에 db폴더를 추가하여 database.js 파일 생성
    - import mysql from 'mysql2';로 db 연결하고
    - 접속할 host 정보를 추가(.env 및 config.js 파일을 이용하여 database.js에는 변수로 입력되게끔.)

✔ db에서 데이터를 가져오기위해 sql문으로 수정하기 
- data -> auth.js
    - let 변수로 직접 넣은 정보를 삭제하고, import { db } from '../db/database.js';로 데이터베이스를 import.
    - findByUsername(username),createUser(user),findById(id) 함수의 실행문을 sql문을 사용하여 수정 

- data - tweets.js
    - let 변수로 직접 넣은 정보를 삭제하고, import { db } from '../db/database.js';로 데이터베이스를 import.
    - create(text, userId)는 insert문으로 text, createdAt, userId를 테이블에 추가하는데, [text, new Date(), userId]값으로 넣는다.

    
<0511>
ORM(Object Relational Mapping)
- 내부적으로 쿼리를 만들어준다.
- sql보다 느리다.
- 복잡한 쿼리는 만들기 쉽지 않다.
- 개발 시 ORM을 사용하는 것이 개발자에게 익숙하고, 코드에 SQL문이 들어가는것보다 가독성이 좋을 수 있다.
- orm에서 지원하는 sql쿼리를 넣을 수 있다.

Sequlize (ORM tool)
- 설치: npm install sequelize
- db - database.js
    - mysql2 import한 코드 삭제해도 되고, import SQ from 'sequelize';추가.
    - 아래 코드 추가
    const { host, user, database, password } = config.db;
    export const sequelize = new SQ.Sequelize(database, user, password, {
        host,
        dialect: 'mysql',
        logging: false
    })

- index.js
    - import { sequelize } from './db/database.js'
    - sequelize.sync().then((client) => {
    console.log(client)
})

-  data 폴더 내 파일들에서 import { db } from './db/database.js'다 지우기